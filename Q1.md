Q1. “A user double-clicks ‘Pay Now’ in your e-commerce app. How do you prevent two payments?”

Tests: Do you know about idempotency keys + DB unique constraints.

Expected Answer:

Client generates an idempotency key and sends it with the request.

Server stores request/result against that key (Redis/MySQL).

Replays with the same key return the same response.

On DB side, enforce UNIQUE(payment_ref) so only one record is created.

Q2. “How would you implement idempotency for webhooks from Stripe/Razorpay?”

Tests: Awareness of external retries.

Expected Answer:

Use event.id as a deduplication key.

Store it in Redis/MySQL with a TTL.

If seen again, skip processing.

Make webhook handler idempotent (e.g., set order.status = PAID rather than increment balance).

Q3. “If I retry a refund request 3 times, how do you ensure money is only returned once?”

Tests: Can you apply natural unique keys.

Expected Answer:

Use refund_reference (gateway ID or client key).

Make it UNIQUE in DB.

First insert succeeds, later retries fail gracefully (and return existing refund).

Q4. “What happens if two concurrent requests come with the same idempotency key?”

Tests: Understanding of concurrent deduplication.