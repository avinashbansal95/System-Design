# Webhook Idempotency with Redis + MySQL + Node.js

A complete implementation for handling webhook idempotency using Redis for locking and MySQL for persistent storage. This ensures webhook events are processed exactly once, even with provider retries.

## Table of Contents

- [Webhook Idempotency with Redis + MySQL + Node.js](#webhook-idempotency-with-redis--mysql--nodejs)
  - [Table of Contents](#table-of-contents)
  - [Overview](#overview)
  - [Key Features](#key-features)
  - [Implementation](#implementation)
    - [Webhook Service](#webhook-service)
    - [Express Controller](#express-controller)
    - [Database Schema](#database-schema)
    - [Usage Example](#usage-example)
  - [How It Works](#how-it-works)
  - [Configuration](#configuration)
    - [Environment Variables](#environment-variables)
    - [Redis Key Patterns](#redis-key-patterns)

## Overview

Payment providers (Stripe, Razorpay, etc.) retry webhook delivery until they receive a 2xx response. Without proper idempotency handling, this can lead to:

- Duplicate order status updates
- Double refund processing  
- Inconsistent payment states
- Race conditions with concurrent requests

This implementation provides robust webhook idempotency using Redis locks and MySQL persistence.

## Key Features

- ✅ **Event ID Deduplication**: Uses `event.id` as the idempotency key
- ✅ **Redis Locking**: Prevents concurrent processing of the same webhook event
- ✅ **Result Caching**: Stores processing results with TTL to handle retries
- ✅ **Database Persistence**: Long-term storage of webhook events and results
- ✅ **Idempotent Operations**: Uses `UPDATE ... WHERE status !=` pattern for safe retries
- ✅ **Provider Agnostic**: Supports both Stripe and Razorpay webhooks
- ✅ **Status Endpoint**: Allows checking processing status of any webhook event

## Implementation

### Webhook Service

```javascript
// webhook-service.js
const redis = require('redis');
const mysql = require('mysql2/promise');
const crypto = require('crypto');

class WebhookService {
  constructor() {
    this.redisClient = redis.createClient({
      url: process.env.REDIS_URL || 'redis://localhost:6379'
    });
    
    this.mysqlPool = mysql.createPool({
      host: process.env.DB_HOST || 'localhost',
      user: process.env.DB_USER || 'root',
      password: process.env.DB_PASSWORD || '',
      database: process.env.DB_NAME || 'ecommerce',
      connectionLimit: 10
    });
    
    this.connectRedis();
    
    // Webhook processing configuration
    this.config = {
      lockTimeout: 30000,     // 30 seconds lock duration
      resultTTL: 86400 * 7,   // 7 days for result storage
      maxRetries: 3           // Maximum processing retries
    };
  }

  async connectRedis() {
    await this.redisClient.connect();
    console.log('Connected to Redis');
  }

  // Main webhook processing method
  async processWebhook(event, provider) {
    const eventId = event.id;
    const eventType = event.type;
    
    if (!eventId) {
      throw new Error('Webhook event missing ID');
    }

    try {
      // Try to acquire lock for this event
      const lockAcquired = await this.acquireWebhookLock(eventId);
      
      if (!lockAcquired) {
        // Event is already being processed
        return {
          processed: false,
          status: 'already_processing',
          message: 'Webhook event is already being processed'
        };
      }

      // Check if we've already processed this event
      const existingResult = await this.checkExistingWebhook(eventId);
      if (existingResult) {
        await this.releaseWebhookLock(eventId);
        return {
          processed: false,
          status: 'already_processed',
          message: 'Webhook event was already processed',
          previous_result: existingResult
        };
      }

      // Process the webhook event based on type
      const processingResult = await this.executeWebhookProcessing(event, provider);
      
      // Store the processing result
      await this.storeWebhookResult(eventId, processingResult);
      
      // Release the lock
      await this.releaseWebhookLock(eventId);
      
      return {
        processed: true,
        status: 'success',
        result: processingResult
      };

    } catch (error) {
      // Ensure lock is released on error
      await this.releaseWebhookLock(eventId, true);
      throw error;
    }
  }

  // Acquire lock for webhook processing
  async acquireWebhookLock(eventId, retries = this.config.maxRetries) {
    const lockKey = `webhook:lock:${eventId}`;
    
    for (let attempt = 0; attempt < retries; attempt++) {
      try {
        const result = await this.redisClient.set(
          lockKey,
          'processing',
          {
            NX: true,
            EX: Math.floor(this.config.lockTimeout / 1000)
          }
        );
        
        if (result === 'OK') {
          return true;
        }
        
        // Wait before retrying
        if (attempt < retries - 1) {
          await new Promise(resolve => setTimeout(resolve, 200 * Math.pow(2, attempt)));
        }
      } catch (error) {
        console.error(`Error acquiring webhook lock (attempt ${attempt + 1}):`, error);
        if (attempt === retries - 1) throw error;
      }
    }
    
    return false;
  }

  // Check if webhook was already processed
  async checkExistingWebhook(eventId) {
    try {
      const result = await this.redisClient.get(`webhook:result:${eventId}`);
      if (result) {
        return JSON.parse(result);
      }
      
      // Also check database for persistence
      const connection = await this.mysqlPool.getConnection();
      const [rows] = await connection.execute(
        'SELECT event_data, processing_result FROM webhook_events WHERE event_id = ?',
        [eventId]
      );
      connection.release();
      
      if (rows.length > 0) {
        return rows[0].processing_result;
      }
      
      return null;
    } catch (error) {
      console.error('Error checking existing webhook:', error);
      return null;
    }
  }

  // Execute webhook processing based on event type
  async executeWebhookProcessing(event, provider) {
    const eventType = event.type;
    const eventId = event.id;
    
    console.log(`Processing ${provider} webhook: ${eventType} (${eventId})`);
    
    try {
      switch (eventType) {
        case 'payment_intent.succeeded':
        case 'payment.captured':
          return await this.handleSuccessfulPayment(event, provider);
          
        case 'payment_intent.payment_failed':
        case 'payment.failed':
          return await this.handleFailedPayment(event, provider);
          
        case 'charge.refunded':
        case 'refund.processed':
          return await this.handleRefund(event, provider);
          
        default:
          return {
            status: 'skipped',
            message: `Unhandled event type: ${eventType}`
          };
      }
    } catch (error) {
      console.error(`Error processing ${eventType}:`, error);
      throw error;
    }
  }

  // Handle successful payment event
  async handleSuccessfulPayment(event, provider) {
    const connection = await this.mysqlPool.getConnection();
    
    try {
      await connection.beginTransaction();
      
      // Extract relevant data based on provider
      let paymentId, orderId, amount;
      
      if (provider === 'stripe') {
        paymentId = event.data.object.id;
        orderId = event.data.object.metadata.order_id;
        amount = event.data.object.amount / 100; // Convert from cents
      } else if (provider === 'razorpay') {
        paymentId = event.payload.payment.entity.id;
        orderId = event.payload.payment.entity.notes.order_id;
        amount = event.payload.payment.entity.amount / 100; // Convert from paise
      }
      
      if (!orderId) {
        throw new Error('Order ID not found in webhook payload');
      }
      
      // Update order status to PAID (idempotent operation)
      const [result] = await connection.execute(
        `UPDATE orders 
         SET payment_status = 'PAID', 
             updated_at = NOW() 
         WHERE id = ? AND payment_status != 'PAID'`,
        [orderId]
      );
      
      // Record the payment
      if (result.affectedRows > 0) {
        await connection.execute(
          `INSERT INTO payments 
           (order_id, payment_id, amount, provider, status, created_at) 
           VALUES (?, ?, ?, ?, 'completed', NOW())`,
          [orderId, paymentId, amount, provider]
        );
      }
      
      await connection.commit();
      
      return {
        action: 'payment_success',
        order_id: orderId,
        payment_id: paymentId,
        amount: amount,
        changed: result.affectedRows > 0
      };
      
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  // Handle failed payment event
  async handleFailedPayment(event, provider) {
    const connection = await this.mysqlPool.getConnection();
    
    try {
      await connection.beginTransaction();
      
      let paymentId, orderId, errorMessage;
      
      if (provider === 'stripe') {
        paymentId = event.data.object.id;
        orderId = event.data.object.metadata.order_id;
        errorMessage = event.data.object.last_payment_error?.message || 'Unknown error';
      } else if (provider === 'razorpay') {
        paymentId = event.payload.payment.entity.id;
        orderId = event.payload.payment.entity.notes.order_id;
        errorMessage = event.payload.payment.entity.error_description || 'Unknown error';
      }
      
      if (!orderId) {
        throw new Error('Order ID not found in webhook payload');
      }
      
      // Update order status to FAILED (idempotent operation)
      const [result] = await connection.execute(
        `UPDATE orders 
         SET payment_status = 'FAILED', 
             updated_at = NOW() 
         WHERE id = ? AND payment_status != 'FAILED'`,
        [orderId]
      );
      
      // Record the failed payment attempt
      if (result.affectedRows > 0) {
        await connection.execute(
          `INSERT INTO payments 
           (order_id, payment_id, amount, provider, status, error_message, created_at) 
           VALUES (?, ?, 0, ?, 'failed', ?, NOW())`,
          [orderId, paymentId, provider, errorMessage]
        );
      }
      
      await connection.commit();
      
      return {
        action: 'payment_failed',
        order_id: orderId,
        payment_id: paymentId,
        error: errorMessage,
        changed: result.affectedRows > 0
      };
      
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  // Handle refund event
  async handleRefund(event, provider) {
    const connection = await this.mysqlPool.getConnection();
    
    try {
      await connection.beginTransaction();
      
      let refundId, paymentId, amount, orderId;
      
      if (provider === 'stripe') {
        refundId = event.data.object.id;
        paymentId = event.data.object.payment_intent;
        amount = event.data.object.amount / 100;
        // Need to lookup orderId from paymentId
      } else if (provider === 'razorpay') {
        refundId = event.payload.refund.entity.id;
        paymentId = event.payload.refund.entity.payment_id;
        amount = event.payload.refund.entity.amount / 100;
        // Need to lookup orderId from paymentId
      }
      
      // Get order ID from payment
      const [payments] = await connection.execute(
        'SELECT order_id FROM payments WHERE payment_id = ?',
        [paymentId]
      );
      
      if (payments.length === 0) {
        throw new Error(`Payment not found: ${paymentId}`);
      }
      
      orderId = payments[0].order_id;
      
      // Update order status to REFUNDED (idempotent operation)
      const [result] = await connection.execute(
        `UPDATE orders 
         SET payment_status = 'REFUNDED', 
             updated_at = NOW() 
         WHERE id = ? AND payment_status != 'REFUNDED'`,
        [orderId]
      );
      
      // Record the refund
      if (result.affectedRows > 0) {
        await connection.execute(
          `INSERT INTO refunds 
           (order_id, payment_id, refund_id, amount, provider, created_at) 
           VALUES (?, ?, ?, ?, ?, NOW())`,
          [orderId, paymentId, refundId, amount, provider]
        );
      }
      
      await connection.commit();
      
      return {
        action: 'refund_processed',
        order_id: orderId,
        payment_id: paymentId,
        refund_id: refundId,
        amount: amount,
        changed: result.affectedRows > 0
      };
      
    } catch (error) {
      await connection.rollback();
      throw error;
    } finally {
      connection.release();
    }
  }

  // Store webhook processing result
  async storeWebhookResult(eventId, result) {
    try {
      // Store in Redis with TTL
      await this.redisClient.set(
        `webhook:result:${eventId}`,
        JSON.stringify(result),
        {
          EX: this.config.resultTTL
        }
      );
      
      // Also persist in database for long-term storage
      const connection = await this.mysqlPool.getConnection();
      await connection.execute(
        `INSERT INTO webhook_events 
         (event_id, event_data, processing_result, created_at) 
         VALUES (?, ?, ?, NOW())
         ON DUPLICATE KEY UPDATE processing_result = VALUES(processing_result)`,
        [eventId, JSON.stringify(result), JSON.stringify(result)]
      );
      connection.release();
      
    } catch (error) {
      console.error('Error storing webhook result:', error);
      // Don't throw error as this is secondary to the main processing
    }
  }

  // Release webhook lock
  async releaseWebhookLock(eventId, force = false) {
    const lockKey = `webhook:lock:${eventId}`;
    
    try {
      if (force) {
        await this.redisClient.del(lockKey);
        return true;
      }
      
      // Use transaction to safely release only if we own the lock
      const multi = this.redisClient.multi();
      multi.get(lockKey);
      const results = await multi.exec();
      
      if (results && results[0] === 'processing') {
        await this.redisClient.del(lockKey);
        return true;
      }
      
      return false;
    } catch (error) {
      console.error('Error releasing webhook lock:', error);
      return false;
    }
  }

  // Get webhook processing status
  async getWebhookStatus(eventId) {
    try {
      const lockValue = await this.redisClient.get(`webhook:lock:${eventId}`);
      const resultValue = await this.redisClient.get(`webhook:result:${eventId}`);
      
      let status = 'unknown';
      if (lockValue === 'processing') status = 'processing';
      else if (resultValue) status = 'processed';
      
      return {
        event_id: eventId,
        status: status,
        result: resultValue ? JSON.parse(resultValue) : null
      };
    } catch (error) {
      console.error('Error getting webhook status:', error);
      throw error;
    }
  }

  // Cleanup method
  async cleanup() {
    await this.redisClient.quit();
    await this.mysqlPool.end();
  }
}

module.exports = WebhookService;
```

### Express Controller

```javascript
// webhook-controller.js
const express = require('express');
const WebhookService = require('./webhook-service');

const router = express.Router();
const webhookService = new WebhookService();

// Middleware to verify webhook signatures (simplified)
const verifyWebhookSignature = (req, res, next) => {
  const signature = req.headers['stripe-signature'] || req.headers['x-razorpay-signature'];
  
  if (!signature) {
    return res.status(400).json({ error: 'Missing webhook signature' });
  }
  
  // In a real implementation, you would verify the signature here
  // For Stripe: stripe.webhooks.constructEvent(payload, signature, secret)
  // For Razorpay: crypto.createHmac('sha256', secret).update(payload).digest('hex')
  
  req.provider = req.headers['stripe-signature'] ? 'stripe' : 'razorpay';
  next();
};

// Stripe webhook handler
router.post('/stripe', express.raw({ type: 'application/json' }), verifyWebhookSignature, async (req, res) => {
  try {
    const event = req.body;
    const result = await webhookService.processWebhook(event, 'stripe');
    
    res.status(200).json(result);
  } catch (error) {
    console.error('Stripe webhook error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Razorpay webhook handler
router.post('/razorpay', express.json(), verifyWebhookSignature, async (req, res) => {
  try {
    const event = req.body;
    const result = await webhookService.processWebhook(event, 'razorpay');
    
    res.status(200).json(result);
  } catch (error) {
    console.error('Razorpay webhook error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Webhook status endpoint
router.get('/status/:eventId', async (req, res) => {
  try {
    const status = await webhookService.getWebhookStatus(req.params.eventId);
    res.json(status);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
```

### Database Schema

```sql
-- MySQL Schema for Webhook Idempotency
CREATE DATABASE ecommerce;

USE ecommerce;

-- Table for storing webhook events
CREATE TABLE webhook_events (
    id INT AUTO_INCREMENT PRIMARY KEY,
    event_id VARCHAR(255) NOT NULL UNIQUE,
    event_data JSON,
    processing_result JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_event_id (event_id)
);

-- Orders table
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL,
    payment_status ENUM('PENDING', 'PAID', 'FAILED', 'REFUNDED') DEFAULT 'PENDING',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_payment_status (payment_status)
);

-- Payments table
CREATE TABLE payments (
    id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT NOT NULL,
    payment_id VARCHAR(255) NOT NULL,
    amount DECIMAL(10, 2) NOT NULL,
    provider ENUM('stripe', 'razorpay') NOT NULL,
    status ENUM('pending', 'completed', 'failed') DEFAULT 'pending',
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (order_id) REFERENCES orders(id),
    INDEX idx_payment_id (payment_id),
    INDEX idx_order_id (order_id)
);

-- Refunds table
CREATE TABLE refunds (
    id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT NOT NULL,
    payment_id VARCHAR(255) NOT NULL,
    refund_id VARCHAR(255) NOT NULL,
    amount DECIMAL(10, 2) NOT NULL,
    provider ENUM('stripe', 'razorpay') NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (order_id) REFERENCES orders(id),
    INDEX idx_refund_id (refund_id),
    INDEX idx_payment_id (payment_id)
);
```

### Usage Example

```javascript
// app.js
const express = require('express');
const webhookRoutes = require('./webhook-controller');

const app = express();
app.use(express.json());

app.use('/webhooks', webhookRoutes);

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Webhook server running on port ${PORT}`);
});
```

## How It Works

1. **Webhook Received**: Provider sends webhook with unique `event.id`

2. **Lock Acquisition**: System tries to acquire Redis lock using event ID

3. **Duplicate Check**: Verifies if event was already processed  

4. **Idempotent Processing**: Executes business logic with safe operations

5. **Result Storage**: Saves processing result in Redis (with TTL) and MySQL

6. **Lock Release**: Releases lock after processing completes

## Configuration

The webhook service supports the following configuration options:

```javascript
this.config = {
  lockTimeout: 30000,     // 30 seconds lock duration
  resultTTL: 86400 * 7,   // 7 days for result storage  
  maxRetries: 3           // Maximum processing retries
};
```

### Environment Variables

```bash
REDIS_URL=redis://localhost:6379
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=your_password
DB_NAME=ecommerce
PORT=3000
```

### Redis Key Patterns

```
webhook:lock:{eventId}     # Processing lock (30s TTL)
webhook:result:{eventId}   # Processing result (7d TTL)
```

This implementation ensures that webhook events are processed exactly once, handles provider retries gracefully, and provides robust error handling and monitoring capabilities.