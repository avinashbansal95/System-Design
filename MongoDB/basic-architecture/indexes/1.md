let's move on to the next topic indexes in mongodb
where does mongo db stores indexes in RAM or wiredtiger internal cache or at disk?
my question is also below
if indexes are stored in main disk then in some cases it would be slow as some documents are stored in internalc cache(wiredtiger), so they would be more faster than indexes as we need to go toh hard drive for indexes

# MongoDB Indexes & Working Set: The Performance Critical Path

Excellent question. You've hit on the single most important concept for database performance: **the working set**.

Let's break down where indexes are stored and how they are accessed.

## Where Are Indexes Stored?

The answer is: **All of the above.**

1. **On Disk (Permanent Storage)**: Indexes are stored alongside your data in the WiredTiger storage engine's data files on disk. This is the permanent, persistent home for them.

2. **In RAM (The WiredTiger Internal Cache)**: This is the critical part. To be used, portions of the index **must be loaded into the WiredTiger internal cache in RAM.** The database cannot use an index that exists only on disk; it has to read it into memory first.

## How Indexes are Used: The Read Process

Your concern is exactly right. Let's trace a query that uses an index:

### 1. Query
```javascript
db.users.find({ email: "user@example.com" })
```

### 2. Check for Index
MongoDB identifies there is an index on the `email` field.

### 3. Traverse the Index (The Critical Part)
The database must traverse the index tree to find the entry for `"user@example.com"`.

- **If the required parts of the index are in the WiredTiger cache (RAM)**: This traversal happens at RAM speed (nanoseconds). It's incredibly fast.
- **If the required parts of the index are NOT in the cache (a "cache miss")**: The database must perform a **disk read** to load the necessary index pages from disk into the cache. This is slow (milliseconds).

### 4. Get the Document Location
The index entry contains a pointer to the physical location of the document on disk.

### 5. Fetch the Document
- **If the document is in the WiredTiger cache (RAM)**: It is returned immediately (fast).
- **If the document is NOT in the cache**: The database must perform **another disk read** to fetch the document from the data files on disk (slow).

## Answering Your Specific Question

> "if indexes are stored in main disk then in some cases it would be slow as some documents are stored in internal cache(wiredtiger), so they would be more faster than indexes as we need to go to hard drive for indexes"

**You are 100% correct.** This is a classic performance problem.

If your index is too large to fit in the WiredTiger cache, your database performance will be terrible, **even if your documents themselves are tiny and could fit in RAM.**

Why? Because for every query, MongoDB has to read from the slow disk to traverse the index just to find out *where* the document is. It's like having a library where the index card catalog is too big for the room and has to be stored in the basement. To find any book, the librarian first has to take the elevator to the basement to look it up, making every request slow.

## The Golden Rule: The Working Set

This leads to the most critical performance rule for MongoDB (and most databases):

> **Your `working set` (the active portion of your data + all your indexes) must fit in the WiredTiger internal cache (RAM).**

- **If it fits**: Performance is excellent. Nearly all reads are served from RAM.
- **If it doesn't fit**: Performance falls off a cliff. The system becomes **I/O bound**, spending most of its time waiting on slow disk reads.

## Summary for Your Notes

| Scenario | Result | Performance |
|----------|--------|-------------|
| **Index fits in RAM** | Index traversal is done in memory. | **Excellent.** |
| **Index does NOT fit in RAM** | Index traversal requires slow disk reads. | **Terrible.** (Disk I/O bottleneck) |
| **Document fits in RAM** | Document is fetched from memory. | **Excellent.** |
| **Document does NOT fit in RAM** | Document fetch requires slow disk reads. | **Terrible.** (Disk I/O bottleneck) |

## Visual Flow: Query Performance Paths

### Fast Path (Everything in RAM)
```
Query Request
    ↓
Index Traversal (RAM) ← Nanoseconds
    ↓
Document Location Found
    ↓
Document Fetch (RAM) ← Nanoseconds
    ↓
Result Returned ← FAST!
```

### Slow Path (Cache Misses)
```
Query Request
    ↓
Index Traversal → DISK READ ← Milliseconds (slow)
    ↓
Index Loaded to Cache
    ↓
Document Location Found
    ↓
Document Fetch → DISK READ ← Milliseconds (slow)
    ↓
Document Loaded to Cache
    ↓
Result Returned ← SLOW!
```

## Pro Tip

You can check the size of your indexes using:
```javascript
db.collection.totalIndexSize()
```

You must ensure your server has enough RAM to hold your **total index size PLUS your active data**.

## Key Interview Points

> "Index performance is entirely dependent on whether the index pages fit in the WiredTiger cache. Even with perfectly designed indexes, if they don't fit in RAM, every query becomes I/O bound. This is why understanding and sizing the working set (active data + all indexes) is the most critical aspect of MongoDB performance tuning. The working set must fit in the available cache memory, or performance will be unacceptable regardless of other optimizations."