// Transaction A await conn.query("SET TRANSACTION ISOLATION LEVEL READ COMMITTED"); await conn.beginTransaction(); const [r1] = await conn.query("SELECT balance FROM accounts WHERE id = 1"); console.log("A first read:", r1); // meanwhile Transaction B commits: UPDATE accounts SET balance = balance - 100 const [r2] = await conn.query("SELECT balance FROM accounts WHERE id = 1"); console.log("A second read:", r2); // different than r1 â†’ non-repeatable read i understood the problem read committed have in above exmaple of non-repeatable read but why any transaction read the the same data again if he has the data already? give me scenrio using ocd eexmaple


# ðŸ“Œ Why Non-Repeatable Reads Happen in Real Life

## ðŸ”‘ 1. Business Logic That Re-Reads Data

A transaction isn't always just `SELECT once â†’ UPDATE`. Often in business workflows, you:
1. Read data to decide something.
2. Perform other actions.
3. Re-read the same row(s) later in the same transaction to ensure correctness.

ðŸ‘‰ If isolation is too weak, the second read may show different values â†’ logic breaks.

## ðŸ”‘ 2. Example: E-commerce Order (OCD: Order, Customer, Delivery)

### Scenario
* Transaction A = Processing an order placement.
* Business rule: "If balance â‰¥ order price, allow purchase."

### Flow Under **READ COMMITTED**

```javascript
// Transaction A (Order Service)
await conn.query("SET TRANSACTION ISOLATION LEVEL READ COMMITTED");
await conn.beginTransaction();

// Step 1: Check balance
const [r1] = await conn.query(
  "SELECT balance FROM customers WHERE id = 1"
);
console.log("A first read:", r1.balance); // 500

// Step 2: Reserve inventory (takes time... another query, business logic etc.)

// Meanwhile Transaction B (Payment Service) deducts balance
await conn2.query("UPDATE customers SET balance = balance - 300 WHERE id = 1");

// Step 3: Re-check balance before finalizing
const [r2] = await conn.query(
  "SELECT balance FROM customers WHERE id = 1"
);
console.log("A second read:", r2.balance); // Now 200, different than r1
```

ðŸ‘‰ **Problem**:
* At first, Transaction A thought balance = 500.
* After some business steps, when re-checking, balance = 200.
* Decision may flip mid-transaction â†’ **non-repeatable read**.

## ðŸ”‘ 3. Why This Matters

* If A relied on the first read (500) and didn't re-check â†’ it might wrongly allow an order that should fail.
* If A re-checks under **READ COMMITTED**, the result may change (500 â†’ 200).
* Under **REPEATABLE READ**, the balance would remain 500 until A finishes (snapshot isolation).

## ðŸ”‘ 4. Another Example: Reporting

Imagine generating a **monthly invoice** for a customer:
1. Start transaction.
2. Read all purchases (`SELECT SUM(amount)`).
3. Later inside transaction, query purchases again to break down by category.

* Under **READ COMMITTED**, the second read might include a purchase that was just committed by another transaction â†’ invoice values inconsistent within same transaction.

## ðŸŽ¯ Interview-Safe Answer

Non-repeatable reads matter when a transaction re-reads the same row multiple times for business logic. For example, in an e-commerce system, you may read a customer's balance to decide if they can place an order, then perform other steps, and re-read the balance later in the same transaction. Under READ COMMITTED, the second read might see a lower balance if another transaction deducted money in the meantime, leading to inconsistent decisions. REPEATABLE READ prevents this by giving you a consistent snapshot throughout the transaction.