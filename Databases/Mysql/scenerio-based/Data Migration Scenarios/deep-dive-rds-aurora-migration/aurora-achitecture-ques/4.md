where are the indexes are stored in storage layer or ssd of primary or replicas?

# Aurora Index Storage and Caching

Excellent question! This gets to the heart of how Aurora's split between compute and storage works in practice.

The answer is a combination of both, and it's a key performance optimization. Here's the breakdown:

## 1. The "Source of Truth": Storage Layer

The definitive, durable version of all data, including index structures (e.g., B+ trees), is stored in the **distributed storage layer**.

- When the Primary Instance needs to create or modify an index (e.g., during an `ALTER TABLE ... ADD INDEX` or an `INSERT` that updates an index), it doesn't write the index pages to its local disk
- It sends the changes (log records) to the storage layer. The storage layer is responsible for durably storing these changes and eventually applying them to the data pages and index pages it manages
- This ensures that the index is always consistent and available to any instance in the cluster that needs to read it

## 2. The Performance Boost: Caching in Local SSD

While the durable copy is in the shared storage, the **working copies** of index pages and data pages are cached in the local SSD cache of each database instance (both Primary and Replicas).

**This is the most important concept for performance:**

**Primary Instance:** When the Primary needs to read an index to find a row for an `UPDATE`, it first checks its local cache. If the index pages are there, it uses them instantly. If not, it fetches them from the storage layer and caches them for future use. When it writes, it modifies the cached pages and sends the log of changes to the storage layer.

**Replica Instance:** When a Replica runs a `SELECT` query, it works the same way. It checks its own local cache for the needed data and index pages. A cache hit is extremely fast. A cache miss requires a fetch from the storage layer.

## The Clever Part: Cache Coherency

You might ask: "If the Primary updates an index and changes its cache, how does a Replica know its cached index pages are now stale?"

This is managed by the storage layer's **cache invalidation protocol:**

1. The Primary Instance commits a transaction that changes a data or index page. It sends the log record to the storage layer
2. The storage layer acknowledges the write and, as a background process, sends a "gossip" message or invalidation signal to all of the other database instances in the cluster
3. This signal tells the Replicas: "Hey, the page with ID X is now invalid. Discard it from your cache if you have it."
4. The next time a Replica needs that page for a query, it will find its local cache entry is invalidated. It will then fetch the latest version of that page directly from the storage layer, cache it, and then use it

This ensures that all instances are always working with a consistent view of the data without having to constantly check with each other or the storage layer.

## Analogy: A Library with Photocopiers

Imagine the **Shared Storage Layer** is the Library's Central Archive (the single source of truth for all books).

Each **Database Instance** (Primary or Replica) is a Researcher with their own personal photocopier and filing cabinet (the local SSD cache).

An **Index** is like the index at the back of a book.

### How it works:

1. A researcher (the Primary Instance) needs to update the index. They go to the archive, check out the master copy of the book, update the index, and put the master copy back. The archive is now the new truth
2. They also make a photocopy of the updated index pages and put it in their own filing cabinet (caching)
3. The archive sends a memo to all other researchers (Replicas) saying: "The index for Book XYZ is outdated. Please destroy any photocopies you have of it."
4. When another researcher (a Replica) needs to use that index, they first check their own filing cabinet. If they find the old photocopy, they know it's invalid from the memo. They throw it away, go to the central archive, get the latest version, make a new photocopy for their cabinet, and use it

## Summary

| Component | Role in Index Storage |
|-----------|----------------------|
| **Distributed Storage Layer** | Durable Source of Truth. Holds the definitive, permanent version of all index structures. |
| **Local SSD (Primary Instance)** | Working Copy (Cache). Caches hot index pages for extremely fast read/write access. |
| **Local SSD (Replica Instances)** | Working Copy (Cache). Caches hot index pages for extremely fast read-only access. |

This architecture gives you the **best of both worlds:**

- **Durability and Consistency:** The storage layer ensures the index is always safe and consistent
- **Blazing Performance:** The local caches on each instance mean that most operations never have to suffer the network latency of going to the storage layer. They just read from their incredibly fast local NVMe SSD